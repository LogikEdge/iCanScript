///////////////////////////////////////////////////////////
//  FunctionPrototypeUtility.cs
//  Implementation of the Class FunctionPrototypeUtility
//  Generated by Enterprise Architect
//  Created on:      15-Oct-2014 8:37:28 AM
//  Original author: Michel Launier
///////////////////////////////////////////////////////////
using System;
using iCanScript.Editor;
using P=iCanScript.Prelude;
using iCanScript.Engine;


/// <summary>
/// Helper functions to manage the relationship between _FunctionPrototypes_ and
/// their associated nodes.
/// </summary>
public static class iCS_FunctionPrototypeUtility {

	/// <summary>
	/// Creates a node that corresponds to the given function prototype.
	/// </summary>
	/// <param name="prototype"></param>
	public static iCS_IStorage ConvertFunctionPrototypeToNode(iCS_FunctionPrototype prototype){
        
		return null;
	}

	/// <summary>
	/// Creates a function prototype from the given EditorObject.
	/// </summary>
	/// <param name="node"></param>
	public static iCS_FunctionPrototype ConvertNodeToFunctionPrototype(iCS_EngineObject node){
		return null;
	}

	/// <summary>
	/// Determines if the function prototype and the node represent the same definition.
	/// 
	/// </summary>
	/// <param name="prototype"></param>
	/// <param name="node"></param>
	public static bool IsEquivalent(iCS_FunctionPrototype prototype, iCS_EditorObject node){
        var dataPorts= node.BuildListOfChildPorts(p=> p.IsDataPort);
        // Validate return type
        if(!IsReturnTypeEquivalent(prototype, dataPorts)) {
            return false;
        }
        // Validate the instance port (if it exists)
        if(!IsInstanceTypeEquivalent(prototype, dataPorts)) {
            return false;
        }
        // Validate each parameter
        if(!AreAllParameterTypesEquivalent(prototype, dataPorts)) {
            return false;
        }
		return true;
	}

	/// <summary>
	/// Repairs the function prototype to match the given node.
	/// </summary>
	/// <param name="node"></param>
	/// <param name="prototype"></param>
	public static void RepairFunctionPrototype(iCS_EditorObject node, ref iCS_FunctionPrototype prototype){

	}

	/// <summary>
	/// Repairs the node to match the given function prototype
	/// </summary>
	/// <param name="prototype"></param>
	/// <param name="node"></param>
	public static void RepairNode(iCS_FunctionPrototype prototype, ref iCS_EditorObject node){

	}
    
    // =======================================================================
    //  TYPE AND NAME EQUIVALENCE UTILITIES
    // =======================================================================
    /// Returns _'true'_ if the port type and name matches the prototype.
    public static bool IsParameterTypeAndNameEquivalent(iCS_FunctionPrototype prototype, iCS_EditorObject port) {
        if(!IsParameterTypeEquivalent(prototype, port)) {
            return false;
        }
        int paramIdx= port.PortIndex;
        var paramName= prototype.Parameters[paramIdx].name;
        return paramName == port.DisplayName;
    }
    // -----------------------------------------------------------------------
    /// Returns _'true'_ if all port types and names matches the prototype.
    public static bool AreAllParameterTypesAndNamesEquivalent(iCS_FunctionPrototype prototype, iCS_EditorObject[] dataPorts) {
        if(!AreAllParameterTypesEquivalent(prototype, dataPorts)) {
            return false;
        }
        foreach(var p in dataPorts) {
            if(p.PortIndex == (int)iCS_PortIndex.Return || p.PortIndex == (int)iCS_PortIndex.Target) {
                continue;
            }
            if(!IsParameterTypeAndNameEquivalent(prototype, p)) {
                return false;
            }
        }
        return true;        
    }
    
    // =======================================================================
    //  TYPE EQUIVALENCE UTILITIES
    // =======================================================================
    /// Determines if the return type is of the same compiler type.
    public static bool IsReturnTypeEquivalent(iCS_FunctionPrototype prototype, iCS_EditorObject[] dataPorts) {
        var returnPort= Array.Find(dataPorts, p=> p.PortIndex == (int)iCS_PortIndex.Return);
        if(returnPort == null) {
            if(prototype.ReturnType != typeof(void)) return false;
        }
        else {
            if(returnPort.RuntimeType != prototype.ReturnType) return false;
        }
        return true;
    }
    // -----------------------------------------------------------------------
    /// Determine if the parameter port is of the same compiler type.
    public static bool IsParameterTypeEquivalent(iCS_FunctionPrototype prototype, iCS_EditorObject port) {
        int paramIdx= (int)port.PortIndex;
        if(paramIdx < 0 || paramIdx >= P.length(prototype.Parameters)) {
            return false;
        }
        return port.RuntimeType == prototype.Parameters[paramIdx].type;
    }
    // -----------------------------------------------------------------------
    /// Determine if the instance port is of the same compiler type.
    public static bool IsInstanceTypeEquivalent(iCS_FunctionPrototype prototype, iCS_EditorObject[] dataPorts) {
        var instancePort= Array.Find(dataPorts, p=> p.PortIndex == (int)iCS_PortIndex.Target);
        if(instancePort == null) {
            if(prototype.IsInstanceMember) {
                return false;
            }
        }
        else {
            if(prototype.IsClassMember) {
                return false;
            }
            if(instancePort.RuntimeType != prototype.ClassType) {
                return false;
            }
        }
        return true;
    }
    // -----------------------------------------------------------------------
    /// Determines if all the port types are inclusive and present in the 
    /// function prototype.
    public static bool AreAllParameterTypesEquivalent(iCS_FunctionPrototype prototype, iCS_EditorObject[] dataPorts) {
        int nbOfPortsValidated= 0;
        foreach(var p in dataPorts) {
            if(p.PortIndex == (int)iCS_PortIndex.Return || p.PortIndex == (int)iCS_PortIndex.Target) {
                continue;
            }
            ++nbOfPortsValidated;
            if(!IsParameterTypeEquivalent(prototype, p)) {
                return false;
            }
        }
        return nbOfPortsValidated == P.length(prototype.Parameters);
    }
}

